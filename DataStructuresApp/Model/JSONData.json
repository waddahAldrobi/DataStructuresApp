{
    "LessonTitles" : ["Pointers", "Linked Lists"],
    
    "SubLessonTitles": [["Single Pointers", "Double Pointers", "Memory Management", "Quiz"], ["Linked Lists vs Arrays", "Singly and Doubly Linked Lists", "Circulaurly Linked Lists", "Quiz"]],
    
    "Content":
    [
      [{
       "Summary": "<font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">What is a pointer? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Definition: A pointer is a data value that is stored in memory and points to only one memory address at a time. <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nPointers: Stack vs. Heap <font color=\"gray\" strokeColor=\"gray\" face=\"American Typewriter\">\nMemory Stack: <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•stores variables in direct memory and accesses variables very fast. The variables are reserved in Last In First Out (LIFO) order - the last stored block of memory is the first to be freed. <font color=\"gray\" strokeColor=\"gray\" face=\"American Typewriter\">\nMemory Heap: <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•stores variables in dynamic memory and access variables a bit slower. Variables stored in heap can be accessed randomly at any time. Memory in the heap is limited by virtual memory - it is often used when the data at runtime is not known. <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nWhere are pointers stored in memory? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Pointers are always stored in the stack. The data created using the “new” expression are always stored in the heap, whereas the data that pointers referencing an existing variable are stored in the stack. <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nDelete the pointer in stack or heap? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•You cannot delete a pointer stored in stack; however, you MUST delete a pointer whose data is stored in the heap. It is also good practice to set the memory of the pointer to NULL after deleting.",
       "Code": {
       "CellCode": ["#include <iostream>\nusing namespace std;\nint main(){\n\tint var1 = 25;\n\t*ptr1 = &var1;\n\tcout << ptr1;\n\tcout << *ptr1; ", "\tint *ptr2 = new int;\n\t*ptr2 = 5;\n\tcout << ptr2;\n\tcout << *ptr2;"],
       
       "CellRun": ["prints memory address of var1 \nprints 25", "prints memory of ptr2 \nprints 5"],
       
       "CellDesc": ["ptr1 points to memory of var1 \nthe '' prints the value of ptr1", "using '= new int' makes the pointer point to the heap memory"]
       },
       "Visualization": {
       "VisulizationCode": "One half will be an animation that can be stepped through, the other will be descriptions",
       "Images": ["SP1", "SP2", "SP3", "SP4", "SP5"]
       }
       },
       {
       "Summary": "<html> <h1>What is a Double pointer?</h1> <ul> <li>A double pointer is a pointer to a pointer. In C++, pointers can be nested multiple levels but is not suggested for readability.</li></ul> <h1>Can have triple pointers, quadruple pointers, and so on and so forth?</h1> <ul> <li>Yes! Although, there's tyically no need and it's pretty hard to keep track after double pointers.</li></ul> <h1>Where is it used?</h1> <ul> <li>Example use cases: a sentence that can be represented by a summation of letters into words and then words into sentences</li></ul> <h1>Passing Double pointers</h1> <ul> <li>???</li></ul></html>",
       "Code": {
       "CellCode": ["Some Double Pointer Code", "Some more code"],
       
       "CellRun": ["Some Output", "Some Output"],
       
       "CellDesc": ["Some Description", "Some Description"]
       },
       "Visualization": {
       "VisulizationCode": "Some visualization}",
       "Images": ["SP1", "SP2", "SP3", "SP4", "SP5"]
       }
       
       },
       {
       "Summary": "<html> <h1>What's the point?</h1> <ul> <ul> <li>For better or worse, there is no automatic garbage collection in C++. Thus, any memory we use, must be cleaned up by our self. (If you have infinite memory, feel free to ignore this.)</li><li>Pointers created in the stack won’t leave garbage memory because it will always be accessible through some variable.</li></ul> </ul> <h1>Garbage Memory aka. Memory Leak</h1> <ul> <li>Garbage memory is created when pointers are not deleted before they are reassigned.</li></ul> <h1>Dangling Pointers</h1> <ul> <li>These are pointers that reference meaningless data because they were not properly deleted.</li></ul></html>",
       "Code": {
       "CellCode": ["#include <iostream>\nusing namespace std;\nint main(){\n\tint var1 = 25;\n\t*ptr1 = &var1;\n\tprint(ptr1);\n\tprint(*ptr1); ", "\tint *ptr2 = new int;\n\t*ptr2 = 5;\n\tprint(ptr2);\n\tprint(*ptr2)"],
       
       "CellRun": ["prints memory address of var1 \nprints 25", "prints memory of ptr2 \nprints 5"],
       
       "CellDesc": ["ptr1 points to memory of var1 \nthe '' prints the value of ptr1", "using '= new int' makes the pointer point to the heap memory"]
       },
       "Visualization": {
       "VisulizationCode": "#include <iostream>\nusing namespace std;\nint main(){\nint var1 = 25;   // the “&” accesses memory\nint *ptr1 = &var1;    // pointer in stack \n\n// Both of these methods are pointers in heap \nint *ptr2 = new int;\n*ptr2 = 5;\n// OR\nint *ptr2 = new int(5);\n\n\// Deleting heap pointer\ndelete ptr2 ; \ndelete [] ptr2 ;    // If pointer is an array\n}",
       "Images": ["SP1", "SP2", "SP3", "SP4", "SP5"]
       }
       },
       {
       "Quiz": [{
                "Question": "Why can't we rely on the garbage collector to clean up our dangling pointers?",
                "Question-Type": "multiple-choice",
                "Answers": ["Garbage Collectors are unpredictable", "Garbage Collectors are slow", "Who says you can't", "Garbage collectors dont exist in C"],
                "Correct-Answer": [3]
                },
                {
                "Question": "Pointers store the value of a variable",
                "Question-Type": "true-false",
                "Answers": ["True", "False", "", ""],
                "Correct-Answer": [1]
                },
                {
                "Question": "Select all true statements",
                "Question-Type": "select",
                "Answers": ["Pointers can be nested several levels deep", "Pass by reference is an example of pointer like behaviour", "* is used to dereference a pointer", "Data referenced by a pointer can be stored in the stack or the heap"],
                "Correct-Answer": [0, 1, 2, 3]
                },
                {
                "Question": "int b = 10;\nint *c = new int(0);\ncout << b;\nint *d = &b;\n*d += 10 cout << b;\nb += 5;\ncout << *d << c\nSort the output.",
                "Question-Type": "ranking",
                "Answers": ["0X0615", "20", "10", "25"],
                "Correct-Answer": [2, 1, 3, 0]
                }
                ]
       }
       ],
      [{
       "Summary": "<html><h1>What is a Linked List?</h1><ul> <li>Linked Lists are flexible structures that is comprised of nodes that stores data and at least one pointer</li><li>Every Linked List contains a head and a tail. It dictates where the beginning and end of a linked list and is useful for all operations</li></ul><h1>What's the point?</h1><ul> <li>Must faster than an array for insertion and deletion, but not good for searching</li></ul><h1>Runtimes</h1><ul> <li>Search: O(n)</li><li>Insertion: O(1)</li><li>Deletion: O(1)</li></ul></html>",
       "Code": {
       "CellCode": ["#include <iostream>\nusing namespace std;\nint main(){\n\tint var1 = 25;\n\t*ptr1 = &var1;\n\tprint(ptr1);\n\tprint(*ptr1); ", "\tint *ptr2 = new int;\n\t*ptr2 = 5;\n\tprint(ptr2);\n\tprint(*ptr2)"],
       
       "CellRun": ["prints memory address of var1 \nprints 25", "prints memory of ptr2 \nprints 5"],
       
       "CellDesc": ["ptr1 points to memory of var1 \nthe '' prints the value of ptr1", "using '= new int' makes the pointer point to the heap memory"]
       },
       "Visualization": {
       "VisulizationCode": "One half will be an animation that can be stepped through, the other will be descriptions",
       "Images": ["LL1", "LL2", "LL3", "LL4", "LL5", "LL6", "LL7", "LL8"]
       }
       },
       {
       "Summary": "<html><h1>What is a Singly Linked List?</h1><ul> <li>Singly Linked Lists only contain pointers to the next node</li></ul><h1>What's a Doubly Linked List?</h1><ul> <li>Doubly Linked Lists contain pointers to the next node and the previous node</li><li>It makes access to the data available from both end of the list, but at a higher overhead cost</li></ul></html>",
       "Code": {
       "CellCode": ["Some Double Pointer Code", "Some more code"],
       
       "CellRun": ["Some Output", "Some Output"],
       
       "CellDesc": ["Some Description", "Some Description"]
       },
       "Visualization": {
       "VisulizationCode": "Some visualization}",
       "Images": ["SP1", "SP2", "SP3", "SP4", "SP5"]
       }
       
       },
       {
       "Summary": "<html><h1>What is a Circularly Linked List?</h1><ul> <li>Circularly Linked Lists are singly or doubly linked lists where the tail points to the head</li><li>It is typically used to model things circular in nature such as Monopoly the board game</li><li>Its use is especially apparent in queues</li></ul></html>",
       "Code": {
       "CellCode": ["#include <iostream>\nusing namespace std;\nint main(){\n\tint var1 = 25;\n\t*ptr1 = &var1;\n\tprint(ptr1);\n\tprint(*ptr1); ", "\tint *ptr2 = new int;\n\t*ptr2 = 5;\n\tprint(ptr2);\n\tprint(*ptr2)"],
       
       "CellRun": ["prints memory address of var1 \nprints 25", "prints memory of ptr2 \nprints 5"],
       
       "CellDesc": ["ptr1 points to memory of var1 \nthe '' prints the value of ptr1", "using '= new int' makes the pointer point to the heap memory"]
       },
       "Visualization": {
       "VisulizationCode": "#include <iostream>\nusing namespace std;\nint main(){\nint var1 = 25;   // the “&” accesses memory\nint *ptr1 = &var1;    // pointer in stack \n\n// Both of these methods are pointers in heap \nint *ptr2 = new int;\n*ptr2 = 5;\n// OR\nint *ptr2 = new int(5);\n\n\// Deleting heap pointer\ndelete ptr2 ; \ndelete [] ptr2 ;    // If pointer is an array\n}",
       "Images": ["SP1", "SP2", "SP3", "SP4", "SP5"]
       }
       },
       {
       "Quiz": [{
                "Question": "Each node of a singly linked list can only contain a pointer and an int.",
                "Question-Type": "true-false",
                "Answers": ["True", "False", "", ""],
                "Correct-Answer": [1]
                },
                {
                "Question": "Insertion into a singly linked list is O(1)",
                "Question-Type": "true-false",
                "Answers": ["True", "False", "", ""],
                "Correct-Answer": [0]
                },
                {
                "Question": "Select all true statements",
                "Question-Type": "select",
                "Answers": ["Linked Lists are flexible structures", "Each node of a linked list must contain a key value pair and a pointer to the next node", "Data stored in linked lists are sequential in memory", "Circularly Linked Lists are where the tail points to the head"],
                "Correct-Answer": [0, 3]
                },
                {
                "Question": "When we run out of space in a linked list, we typically double the capacity.",
                "Question-Type": "true-false",
                "Answers": ["True", "False ", "", ""],
                "Correct-Answer": [1]
                }
                ]
       }
       ]
      ]
}
    
