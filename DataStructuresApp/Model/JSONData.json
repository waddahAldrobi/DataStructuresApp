{
    "LessonTitles" : ["Pointers", "Linked Lists"],
    
    "SubLessonTitles": [["Single Pointers", "Double Pointers", "Memory Management", "Quiz"], ["Linked Lists vs Arrays", "Singly and Doubly Linked Lists", "Circulaurly Linked Lists", "Quiz"]],
    
    "Content":
    [
      [{
       "Summary": "<font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">What is a pointer? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Definition: A pointer is a data value that is stored in memory and points to only one memory address at a time. <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nPointers: Stack vs. Heap <font color=\"gray\" strokeColor=\"gray\" face=\"American Typewriter\">\nMemory Stack: <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•stores variables in direct memory and accesses variables very fast. The variables are reserved in Last In First Out (LIFO) order - the last stored block of memory is the first to be freed. <font color=\"gray\" strokeColor=\"gray\" face=\"American Typewriter\">\nMemory Heap: <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•stores variables in dynamic memory and access variables a bit slower. Variables stored in heap can be accessed randomly at any time. Memory in the heap is limited by virtual memory - it is often used when the data at runtime is not known. <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nWhere are pointers stored in memory? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Pointers are always stored in the stack. The data created using the “new” expression are always stored in the heap, whereas the data that pointers referencing an existing variable are stored in the stack. <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nDelete the pointer in stack or heap? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•You cannot delete a pointer stored in stack; however, you MUST delete a pointer whose data is stored in the heap. It is also good practice to set the memory of the pointer to NULL after deleting.",
       "Code": {
       "CellCode": ["#include <iostream>\nusing namespace std;\nint main(){\n\tint var1 = 25;\n\t*ptr1 = &var1;\n\tcout << ptr1;\n\tcout << *ptr1; ", "\tint *ptr2 = new int;\n\t*ptr2 = 5;\n\tcout << ptr2;\n\tcout << *ptr2;"],
       
       "CellRun": ["prints memory address of var1 \nprints 25", "prints memory of ptr2 \nprints 5"],
       
       "CellDesc": ["ptr1 points to memory of var1 \nthe '' prints the value of ptr1", "using '= new int' makes the pointer point to the heap memory"]
       },
       "Visualization": {
       "VisulizationCode": "One half will be an animation that can be stepped through, the other will be descriptions",
       "Images": ["SP1", "SP2", "SP3", "SP4", "SP5"]
       }
       },
       {
       "Summary": "<font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">What is a Double pointer? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•A double pointer is a pointer to a pointer. In C++, pointers can be nested multiple levels but is not suggested for readability. <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nCan have triple pointers, quadruple pointers, and so on and so forth? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Yes! Although, there's typically no need and it's pretty hard to keep track after double pointers. <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nWhere is it used? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Example use cases: a sentence that can be represented by a summation of letters into words and then words into sentences <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nUsing Double Pointers <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•You can use the ** to dereference a double pointer, and *** for a triple pointer and so on",
       "Code": {
       "CellCode": ["Some Double Pointer Code", "Some more code"],
       
       "CellRun": ["Some Output", "Some Output"],
       
       "CellDesc": ["Some Description", "Some Description"]
       },
       "Visualization": {
       "VisulizationCode": "Some visualization}",
       "Images": ["SP1", "SP2", "SP3", "SP4", "SP5"]
       }
       
       },
       {
       "Summary": "<html> <h1>What's the point?</h1> <ul> <ul> <li>For better or worse, there is no automatic garbage collection in C++. Thus, any memory we use, must be cleaned up by our self. (If you have infinite memory, feel free to ignore this.)</li><li>Pointers created in the stack won’t leave garbage memory because it will always be accessible through some variable.</li></ul> </ul> <h1>Garbage Memory aka. Memory Leak</h1> <ul> <li>Garbage memory is created when pointers are not deleted before they are reassigned.</li></ul> <h1>Dangling Pointers</h1> <ul> <li>These are pointers that reference meaningless data because they were not properly deleted.</li></ul></html>",
       "Code": {
       "CellCode": ["#include <iostream>\nusing namespace std;\nint main(){\n\tint var1 = 25;\n\t*ptr1 = &var1;\n\tprint(ptr1);\n\tprint(*ptr1); ", "\tint *ptr2 = new int;\n\t*ptr2 = 5;\n\tprint(ptr2);\n\tprint(*ptr2)"],
       
       "CellRun": ["prints memory address of var1 \nprints 25", "prints memory of ptr2 \nprints 5"],
       
       "CellDesc": ["ptr1 points to memory of var1 \nthe '' prints the value of ptr1", "using '= new int' makes the pointer point to the heap memory"]
       },
       "Visualization": {
       "VisulizationCode": "#include <iostream>\nusing namespace std;\nint main(){\nint var1 = 25;   // the “&” accesses memory\nint *ptr1 = &var1;    // pointer in stack \n\n// Both of these methods are pointers in heap \nint *ptr2 = new int;\n*ptr2 = 5;\n// OR\nint *ptr2 = new int(5);\n\n\// Deleting heap pointer\ndelete ptr2 ; \ndelete [] ptr2 ;    // If pointer is an array\n}",
       "Images": ["SP1", "SP2", "SP3", "SP4", "SP5"]
       }
       },
       {
       "Quiz": [{
                "Question": "Why can't we rely on the garbage collector to clean up our dangling pointers?",
                "Question-Type": "multiple-choice",
                "Answers": ["Garbage Collectors are unpredictable", "Garbage Collectors are slow", "Who says you can't", "Garbage collectors dont exist in C"],
                "Correct-Answer": [3]
                },
                {
                "Question": "Pointers store the value of a variable",
                "Question-Type": "true-false",
                "Answers": ["True", "False", "", ""],
                "Correct-Answer": [1]
                },
                {
                "Question": "Select all true statements",
                "Question-Type": "select",
                "Answers": ["Pointers can be nested several levels deep", "Pass by reference is an example of pointer like behaviour", "* is used to dereference a pointer", "Data referenced by a pointer can be stored in the stack or the heap"],
                "Correct-Answer": [0, 1, 2, 3]
                },
                {
                "Question": "int b = 10;\nint *c = new int(0);\ncout << b;\nint *d = &b;\n*d += 10 cout << b;\nb += 5;\ncout << *d << c\nSort the output.",
                "Question-Type": "ranking",
                "Answers": ["0X0615", "20", "10", "25"],
                "Correct-Answer": [2, 1, 3, 0]
                }
                ]
       }
       ],
      [{
       "Summary": "<font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">What is a Linked List? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Linked Lists are flexible structures that is comprised of nodes that stores data and at least one pointer <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Every Linked List contains a head and a tail. It dictates where the beginning and end of a linked list and is useful for all operations <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nWhat's the point? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Must faster than an array for insertion and deletion, but not good for searching <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nRuntimes <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Search: O(n) <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Insertion: O(1) <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Deletion: O(1)",
       "Code": {
       "CellCode": ["struct node{\n\tint data;\n\tnode *next;\n};", "class list{\nprivate:\n\tnode *head, *tail;\npublic:\n\tlist(){\n\t\thead=NULL;\n\t\ttail=NULL;\n}};", "void createnode(int value){\n \tnode *temp=new node;\n \ttemp->data=value;\n \ttemp->next=NULL;\n \tif(head==NULL){\n \t\thead=temp;\n \t\ttail=temp;\n \t\ttemp=NULL;\n \t}\n \telse{\n \t\ttail->next=temp;\n \t\ttail=temp;\n \t}\n}", "void insert_position(int pos, int value){\n \tnode *pre=new node;\n \tnode *cur=new node;\n \tnode *temp=new node;\n \tcur=head;\n \tfor(int i=1;i<pos;i++){\n \t\tpre=cur;\n \t\tcur=cur->next;\n \t}\n \ttemp->data=value;\n \tpre->next=temp;\n \ttemp->next=cur;\n}", "void delete_position(int pos){\n \tnode *current=new node;\n \tnode *previous=new node;\n \tcurrent=head;\n \tfor(int i=1;i<pos;i++){\n \t\tprevious=current;\n \t\tcurrent=current->next;\n \t}\n \tprevious->next=current->next;\n}"],
       
       "CellRun": ["No Output", "No Output", "No Output", "No Output", "No Output"],
       
       "CellDesc": ["The node is the basic repeat unit for our linked list. You can add more primitive data types to be stored at each node.", "This class is the linked list. It consist of the head and tail which is used to keep track of the list.", "To create a node, we need to what to insert and do so while not distrupting the flow of the existing nodes.", "To insert a node in any position is very similar to creating a node. We still create a new node, but we iterate through the linked list until we get to the desired position. We then redirect the previous node to the new node, and the new node points to the next node before we inserted.", "To delete a node we simply itrate through the list to the node, and redirect the next node of the previous, to the next node with respect to the node we have iterated to."]
       },
       "Visualization": {
       "VisulizationCode": "One half will be an animation that can be stepped through, the other will be descriptions",
       "Images": ["LL1", "LL2", "LL3", "LL4", "LL5", "LL6", "LL7", "LL8"]
       }
       },
       {
       "Summary": "<font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">What is a Singly Linked List? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Singly Linked Lists only contain pointers to the next node <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nWhat's a Doubly Linked List? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Doubly Linked Lists contain pointers to the next node and the previous node <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•It makes access to the data available from both end of the list, but at a higher overhead cost <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nCan there be Triply/ Quadruply Linked Lists? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•No, not that mankind knows of, but hey, anything's possible",
       "Code": {
       "CellCode": ["struct node{\n \tint data;\n \tnode *next;\n \tnode *prev;\n};", "class list{\n private:\n \tnode *head, *tail;\n public:\n \tlist(){\n \t\thead=NULL;\n \t\ttail=NULL;\n }};", "void appendnode(int value){\n \tnode *temp=new node;\n \ttemp->data=value;\n \ttemp->next=NULL;\n \tif(head==NULL){\n \t\thead=temp;\n \t\ttail=temp;\n \t\ttemp=NULL;\n \t}\n \telse{\n \t\ttail->next=temp;\n \t\ttemp->prev=tail;\n \t\ttail=temp;\n \t}\n}", "void insert_position(int pos, int value){\n \tnode *pre=new node;\n \tnode *cur=new node;\n \tnode *temp=new node;\n \tcur=head;\n \tfor(int i=1;i<pos;i++){\n \t\tpre=cur;\n \t\tcur=cur->next;\n \t}\n \ttemp->data=value;\n \tpre->next=temp;\n \ttemp->next=cur;\n \tcur->prev=temp;\n \ttemp->prev=pre;\n}", "void delete_position(int pos){\n \tnode *current=new node;\n \tnode *previous=new node;\n \tcurrent=head;\n \tfor(int i=1;i<pos;i++){\n \t\tprevious=current;\n \t\tcurrent=current->next;\n \t}\n \tprevious->next=current->next;\n \tcurrent->next->prev=previous\n}"],
       
       "CellRun": ["No Output", "No Output", "No Output", "No Output", "No Output"],
       
       "CellDesc": ["The node is just like that of a singly linked list, we just need an additional pointer for the previous node.", "The list class itself, has no change.", "The doubly linked list is very similar to the singly linked list. As you can see, there is only one additional line necccesary to update the previous node.", "Similar to before, we simply need to update the previous pointers for newly inserted node \"temp\" and the node after it.", "Again, the only additional thing we need to update is the previous pointer of the node after the one we wish to delete."]
       },
       "Visualization": {
       "VisulizationCode": "Some visualization}",
       "Images": ["SP1", "SP2", "SP3", "SP4", "SP5"]
       }
       
       },
       {
       "Summary": "<font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">What is a Circularly Linked List? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Circularly Linked Lists are singly or doubly linked lists where the tail points to the head <font color=\"blue\" strokeColor=\"blue\" face=\"American Typewriter\">\n\nWhere is it used? <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•It is typically used to model things circular in nature such as Monopoly the board game or the Josephus problem <font color=\"black\" strokeColor=\"black\" face=\"American Typewriter\">\n•Its use is especially apparent in queues(upcoming) ",
       "Code": {
       "CellCode": ["void appendnode(int value){\n \tnode *temp=new node;\n \ttemp->data=value;\n \ttemp->next=NULL;\n \tif(head==NULL){\n \t\thead=temp;\n \t\ttail=temp;\n \t}\n \telse{\n \t\ttail->next=temp;\n \t\ttemp->prev=tail;\n \t\ttail=temp;\n \t}\n \ttail->next=head;\n}"],
       
       "CellRun": ["No Output"],
       
       "CellDesc": ["The only difference here is that the tail points to the head."]
       },
       "Visualization": {
       "VisulizationCode": "#include <iostream>\nusing namespace std;\nint main(){\nint var1 = 25;   // the “&” accesses memory\nint *ptr1 = &var1;    // pointer in stack \n\n// Both of these methods are pointers in heap \nint *ptr2 = new int;\n*ptr2 = 5;\n// OR\nint *ptr2 = new int(5);\n\n\// Deleting heap pointer\ndelete ptr2 ; \ndelete [] ptr2 ;    // If pointer is an array\n}",
       "Images": ["SP1", "SP2", "SP3", "SP4", "SP5"]
       }
       },
       {
       "Quiz": [{
                "Question": "Each node of a singly linked list can only contain a pointer and an int.",
                "Question-Type": "true-false",
                "Answers": ["True", "False", "", ""],
                "Correct-Answer": [1]
                },
                {
                "Question": "Insertion into a singly linked list is O(1)",
                "Question-Type": "true-false",
                "Answers": ["True", "False", "", ""],
                "Correct-Answer": [0]
                },
                {
                "Question": "Select all true statements",
                "Question-Type": "select",
                "Answers": ["Linked Lists are flexible structures", "Each node of a linked list must contain a key value pair and a pointer to the next node", "Data stored in linked lists are sequential in memory", "Circularly Linked Lists are where the tail points to the head"],
                "Correct-Answer": [0, 3]
                },
                {
                "Question": "When we run out of space in a linked list, we typically double the capacity.",
                "Question-Type": "true-false",
                "Answers": ["True", "False ", "", ""],
                "Correct-Answer": [1]
                }
                ]
       }
       ]
      ]
}
    
